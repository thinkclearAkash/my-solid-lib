// The breakpoint **start** at this value.
// For instance with the first breakpoint xs: [xs, sm[.
export const values = {
    xs: 0, // phone
    sm: 600, // tablets
    md: 900, // small laptop
    lg: 1200, // desktop
    xl: 1536, // large screens
};
export function handleBreakpoints(props, propValue, styleFromPropValue) {
    const theme = props.theme || {};
    if (Array.isArray(propValue)) {
        const themeBreakpoints = theme.breakpoints;
        return propValue.reduce((acc, item, index) => {
            acc = {
                ...acc,
                ...themeBreakpoints.up(themeBreakpoints.keys[index], styleFromPropValue(propValue[index])),
            };
            return acc;
        }, {});
    }
    if (typeof propValue === "object") {
        const themeBreakpoints = theme.breakpoints;
        const keys = Object.keys(propValue);
        return keys.reduce((acc, breakpoint) => {
            // key is breakpoint
            if (Object.keys(themeBreakpoints.values || values).indexOf(breakpoint) !==
                -1) {
                acc = {
                    ...acc,
                    ...themeBreakpoints.up(breakpoint, styleFromPropValue(propValue[breakpoint], breakpoint)),
                };
            }
            else {
                const cssKey = breakpoint;
                acc[cssKey] = propValue[cssKey];
            }
            return acc;
        }, {});
    }
    const output = styleFromPropValue(propValue);
    return output;
}
export function getOffset(val) {
    const parse = parseFloat(val.toString());
    return `${parse}${String(val).replace(String(parse), "") || "px"}`;
}
export function computeBreakpointsBase(values, breakpoints) {
    const base = {};
    // fixed value
    if (typeof values !== "object") {
        return base;
    }
    const breakpointsKeys = Object.keys(breakpoints);
    if (Array.isArray(values)) {
        breakpointsKeys.forEach((breakpoint, i) => {
            if (i < values.length) {
                base[breakpoint] = true;
            }
        });
    }
    else {
        breakpointsKeys.forEach((breakpoint) => {
            if (values[breakpoint] != null) {
                base[breakpoint] = true;
            }
        });
    }
    return base;
}
export function resolveBreakpointValues(data) {
    const values = data.values;
    const base = data.base ||
        computeBreakpointsBase(values, data.breakpoints || {});
    const keys = Object.keys(base);
    if (keys.length === 0) {
        return data.values;
    }
    let previous;
    return keys.reduce((acc, breakpoint, i) => {
        if (Array.isArray(values)) {
            acc[breakpoint] =
                values[i] != null ? values[i] : values[previous];
            previous = i;
        }
        else if (typeof values === "number") {
            acc[breakpoint] = values;
        }
        else {
            acc[breakpoint] =
                values[breakpoint] != null
                    ? values[breakpoint]
                    : values[previous];
            previous = breakpoint;
        }
        return acc;
    }, {});
}
